/**
 * Formula Evaluator
 *
 * This class walks the Abstract Syntax Tree (AST) generated by the Parser
 * and computes a final value. It is a stateless, recursive visitor.
 */

// --- 1. Import our utilities (no more placeholders) ---
import { TypeCoercion } from './utils/TypeCoercion.js';
import {
  FormulaError,
  DivZeroError,
  NameError,
} from './utils/FormulaErrors.js';

class Evaluator {
  /**
   * Creates a new Evaluator instance.
   */
  constructor({ getCellValue, getRangeValues, functionRegistry }) {
    this.getCellValue = getCellValue;
    this.getRangeValues = getRangeValues;
    this.functionRegistry = functionRegistry;

    // Use the imported utilities
    this.coerce = TypeCoercion;
    this.FormulaError = FormulaError;
    this.DivZeroError = DivZeroError;
    this.NameError = NameError;
  }

  /**
   * Public method to evaluate an AST node.
   */
  evaluate(node) {
    try {
      return this._visit(node);
    } catch (e) {
      if (e instanceof this.FormulaError) {
        return e; // Return the error object (e.g., #DIV/0!)
      }
      // Re-throw unexpected runtime errors
      console.error('Unhandled Evaluator Error:', e);
      throw e;
    }
  }

  /**
   * Private recursive visitor method.
   */
  _visit(node) {
    switch (node.type) {
      // --- Literals ---
      case 'number':
      case 'string':
      case 'boolean':
        return node.value;

      // --- References ---
      case 'cell':
        return this.getCellValue(node.ref);
      case 'range':
        return this.getRangeValues(node.start, node.end);

      // --- Structure ---
      case 'group':
        return this._visit(node.expression);

      // --- Unary Operator ---
      case 'unary':
        const operand = this._visit(node.operand);
        if (node.op === '-') {
          return -this.coerce.toNumber(operand);
        }
        if (node.op === '+') {
          return this.coerce.toNumber(operand);
        }
        break;

      // --- Binary Operators ---
      case 'operator':
        const left = this._visit(node.left);
        const right = this._visit(node.right);
        return this._performOperation(node.op, left, right);

      // --- Function Call ---
      case 'function':
        const func = this.functionRegistry.get(node.name);
        if (!func) {
          throw new this.NameError(`Unknown function: ${node.name}`);
        }
        const args = node.args.map((arg) => this._visit(arg));
        return func.call(this, ...args);

      default:
        throw new Error(`Unknown AST node type: ${node.type}`);
    }
  }

  /**
   * Helper to perform binary operations.
   */
  _performOperation(op, left, right) {
    // --- Math Operations ---
    if (op === '+') {
      return this.coerce.toNumber(left) + this.coerce.toNumber(right);
    }
    if (op === '-') {
      return this.coerce.toNumber(left) - this.coerce.toNumber(right);
    }
    if (op === '*') {
      return this.coerce.toNumber(left) * this.coerce.toNumber(right);
    }
    if (op === '/') {
      const rightNum = this.coerce.toNumber(right);
      if (rightNum === 0) {
        throw new this.DivZeroError('Division by zero');
      }
      return this.coerce.toNumber(left) / rightNum;
    }
    if (op === '^') {
      return Math.pow(this.coerce.toNumber(left), this.coerce.toNumber(right));
    }

    // --- Concatenation ---
    if (op === '&') {
      return this.coerce.toString(left) + this.coerce.toString(right);
    }

    // --- Comparison Operations ---
    if (op === '=') {
      return left === right;
    }
    if (op === '<>' || op === '!=') {
      return left !== right;
    }
    if (op === '<') {
      return this.coerce.compare(left, right) < 0;
    }
    if (op === '<=') {
      return this.coerce.compare(left, right) <= 0;
    }
    if (op === '>') {
      return this.coerce.compare(left, right) > 0;
    }
    if (op === '>=') {
      return this.coerce.compare(left, right) >= 0;
    }

    throw new Error(`Unknown operator: ${op}`);
  }
}

// --- 3. Fix the export ---
export { Evaluator };
