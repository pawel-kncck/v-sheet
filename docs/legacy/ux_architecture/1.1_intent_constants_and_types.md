# Step-by-Step Implementation: Chunk 1.1 – Intent Constants & Types

## Objective

Create `js/modes/Intents.js` – the foundational vocabulary for the entire input/state management system. This file defines all semantic intents and provides factory functions for creating properly-structured context objects.

---

## Prerequisites

- Working v-sheet development environment
- Understanding of the current keyboard handling in `js/spreadsheet.js` (specifically `_handleGlobalKeydown`)

---

## Step 1: Create the Directory Structure

**Action:** Create the `modes` directory inside `js/`.

```bash
mkdir -p js/modes
```

**Rationale:** All mode-related code will live in this directory, keeping the architecture organized and discoverable.

---

## Step 2: Create the File with Header Documentation

**Action:** Create `js/modes/Intents.js` with a documentation header.

```javascript
/**
 * Intents.js
 *
 * Defines the semantic vocabulary for user interactions in the spreadsheet.
 *
 * The Intent system decouples "what the user pressed" (raw DOM events) from
 * "what the user wants to do" (semantic actions). This allows:
 *
 * 1. InputController to normalize platform differences (Cmd vs Ctrl)
 * 2. Modes to handle intents without knowing about specific keys
 * 3. Easy remapping of keyboard shortcuts in the future
 *
 * @module modes/Intents
 */
```

**Rationale:** Clear documentation helps future developers understand the purpose of this abstraction layer.

---

## Step 3: Define the INTENTS Enumeration

**Action:** Add the intent constants object.

```javascript
/**
 * Enumeration of all semantic intents in the application.
 *
 * These are the "verbs" of user interaction. InputController translates
 * raw events into these intents, and Modes decide how to handle them.
 *
 * @readonly
 * @enum {string}
 */
export const INTENTS = Object.freeze({
  // --- Navigation ---
  /** Move selection or cursor. Context: { direction, shift, ctrl } */
  NAVIGATE: 'NAVIGATE',

  /** Jump to edge of data region. Context: { direction, shift } */
  JUMP_TO_EDGE: 'JUMP_TO_EDGE',

  // --- Editing Lifecycle ---
  /** Begin editing the active cell (F2, double-click). Context: { source: 'keyboard' | 'mouse' } */
  EDIT_START: 'EDIT_START',

  /** Commit current operation (Enter, Tab). Context: { moveDirection: 'down' | 'right' | 'none' } */
  COMMIT: 'COMMIT',

  /** Cancel current operation (Escape). Context: none */
  CANCEL: 'CANCEL',

  // --- Text Input ---
  /** Character input. Context: { char, isFormulaTrigger } */
  INPUT: 'INPUT',

  // --- Deletion ---
  /** Delete content (Backspace, Delete). Context: { key: 'backspace' | 'delete' } */
  DELETE: 'DELETE',

  // --- History ---
  /** Undo last action (Ctrl+Z). Context: none */
  UNDO: 'UNDO',

  /** Redo last undone action (Ctrl+Y, Ctrl+Shift+Z). Context: none */
  REDO: 'REDO',

  // --- Clipboard ---
  /** Copy selection (Ctrl+C). Context: none */
  COPY: 'COPY',

  /** Paste from clipboard (Ctrl+V). Context: none */
  PASTE: 'PASTE',

  /** Cut selection (Ctrl+X). Context: none */
  CUT: 'CUT',

  // --- Selection ---
  /** Select all cells (Ctrl+A). Context: none */
  SELECT_ALL: 'SELECT_ALL',

  /** Cell clicked/selected. Context: { coords, shift, ctrl } */
  CELL_SELECT: 'CELL_SELECT',

  /** Header clicked. Context: { type: 'row' | 'col', index, shift, ctrl } */
  HEADER_SELECT: 'HEADER_SELECT',

  // --- Formatting ---
  /** Toggle bold (Ctrl+B). Context: none */
  FORMAT_BOLD: 'FORMAT_BOLD',

  /** Toggle italic (Ctrl+I). Context: none */
  FORMAT_ITALIC: 'FORMAT_ITALIC',
});
```

**Rationale:**

- `Object.freeze()` prevents accidental mutation of the enum
- Each intent is documented with its expected context shape
- Intents are grouped by category for readability
- Using strings (not symbols) allows for easier debugging and logging

**Design Decision – NAVIGATE vs JUMP_TO_EDGE:**

Looking at the current `_handleGlobalKeydown`, the Ctrl+Arrow behavior is distinct enough to warrant its own intent. This keeps the context objects simpler and makes mode logic clearer:

```javascript
// Current code in spreadsheet.js:
if (isCmd) {
  this.selectionManager.jumpToEdge(direction, ...);
} else {
  this.selectionManager.moveSelection(direction, isShift);
}
```

With separate intents, this decision moves to InputController, and modes just handle the intent they receive.

---

## Step 4: Define Direction Constants

**Action:** Add direction enumeration for navigation intents.

```javascript
/**
 * Valid directions for navigation intents.
 * @readonly
 * @enum {string}
 */
export const DIRECTIONS = Object.freeze({
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right',
});
```

**Rationale:** Prevents typos and enables autocomplete. The lowercase values match what `SelectionManager.moveSelection()` already expects.

---

## Step 5: Create the Navigate Context Factory

**Action:** Add factory function for navigation context.

```javascript
/**
 * Creates a context object for NAVIGATE intents.
 *
 * @param {string} direction - One of DIRECTIONS values
 * @param {boolean} [shift=false] - Whether Shift is held (extend selection)
 * @returns {Object} Navigation context
 *
 * @example
 * // Arrow Right
 * createNavigateContext(DIRECTIONS.RIGHT)
 * // => { direction: 'right', shift: false }
 *
 * @example
 * // Shift+Arrow Down (extend selection)
 * createNavigateContext(DIRECTIONS.DOWN, true)
 * // => { direction: 'down', shift: true }
 */
export function createNavigateContext(direction, shift = false) {
  if (!Object.values(DIRECTIONS).includes(direction)) {
    throw new Error(
      `Invalid direction: ${direction}. Must be one of: ${Object.values(
        DIRECTIONS
      ).join(', ')}`
    );
  }

  return Object.freeze({
    direction,
    shift,
  });
}
```

**Rationale:**

- Factory function ensures consistent object shape
- Validation catches errors early (typos in direction)
- `Object.freeze()` prevents accidental mutation
- Default values reduce boilerplate at call sites
- JSDoc examples serve as documentation and hint at usage

---

## Step 6: Create the Jump Context Factory

**Action:** Add factory function for jump-to-edge context.

```javascript
/**
 * Creates a context object for JUMP_TO_EDGE intents.
 *
 * @param {string} direction - One of DIRECTIONS values
 * @param {boolean} [shift=false] - Whether to extend selection to edge
 * @returns {Object} Jump context
 *
 * @example
 * // Ctrl+Right (jump to edge)
 * createJumpContext(DIRECTIONS.RIGHT)
 * // => { direction: 'right', shift: false }
 *
 * @example
 * // Ctrl+Shift+Right (extend selection to edge)
 * createJumpContext(DIRECTIONS.RIGHT, true)
 * // => { direction: 'right', shift: true }
 */
export function createJumpContext(direction, shift = false) {
  if (!Object.values(DIRECTIONS).includes(direction)) {
    throw new Error(
      `Invalid direction: ${direction}. Must be one of: ${Object.values(
        DIRECTIONS
      ).join(', ')}`
    );
  }

  return Object.freeze({
    direction,
    shift,
  });
}
```

**Rationale:** Same structure as navigate but separate function for clarity. In the future, jump might need additional properties (e.g., `stopAtBlanks`).

---

## Step 7: Create the Input Context Factory

**Action:** Add factory function for character input context.

```javascript
/**
 * Characters that trigger formula mode when typed in Ready state.
 * @readonly
 */
export const FORMULA_TRIGGERS = Object.freeze(['=', '+', '-']);

/**
 * Creates a context object for INPUT intents.
 *
 * @param {string} char - The character that was typed
 * @returns {Object} Input context with formula trigger detection
 *
 * @example
 * // Regular character
 * createInputContext('a')
 * // => { char: 'a', isFormulaTrigger: false }
 *
 * @example
 * // Formula trigger
 * createInputContext('=')
 * // => { char: '=', isFormulaTrigger: true }
 */
export function createInputContext(char) {
  if (typeof char !== 'string' || char.length !== 1) {
    throw new Error(
      `Invalid char: expected single character string, got ${typeof char}: ${char}`
    );
  }

  return Object.freeze({
    char,
    isFormulaTrigger: FORMULA_TRIGGERS.includes(char),
  });
}
```

**Rationale:**

- `isFormulaTrigger` is computed automatically based on the character
- This encapsulates the knowledge of what triggers formula mode in one place
- Validation ensures we don't accidentally pass key names like "Enter" as characters

---

## Step 8: Create the Commit Context Factory

**Action:** Add factory function for commit context.

```javascript
/**
 * Valid move directions after commit.
 * @readonly
 * @enum {string}
 */
export const COMMIT_MOVES = Object.freeze({
  DOWN: 'down', // Enter key
  RIGHT: 'right', // Tab key
  NONE: 'none', // Click away, blur
});

/**
 * Creates a context object for COMMIT intents.
 *
 * @param {string} [moveDirection='down'] - Direction to move after commit
 * @returns {Object} Commit context
 *
 * @example
 * // Enter key (move down)
 * createCommitContext(COMMIT_MOVES.DOWN)
 * // => { moveDirection: 'down' }
 *
 * @example
 * // Tab key (move right)
 * createCommitContext(COMMIT_MOVES.RIGHT)
 * // => { moveDirection: 'right' }
 */
export function createCommitContext(moveDirection = COMMIT_MOVES.DOWN) {
  if (!Object.values(COMMIT_MOVES).includes(moveDirection)) {
    throw new Error(
      `Invalid moveDirection: ${moveDirection}. Must be one of: ${Object.values(
        COMMIT_MOVES
      ).join(', ')}`
    );
  }

  return Object.freeze({
    moveDirection,
  });
}
```

**Rationale:** Matches existing `EditorManager.commitEdit(moveDirection)` parameter, making migration easier.

---

## Step 9: Create the Cell Select Context Factory

**Action:** Add factory function for cell selection context.

```javascript
/**
 * Creates a context object for CELL_SELECT intents.
 *
 * @param {Object} coords - Cell coordinates { row, col }
 * @param {boolean} [shift=false] - Extend selection
 * @param {boolean} [ctrl=false] - Add to selection (multi-select)
 * @returns {Object} Cell select context
 *
 * @example
 * // Simple click on B3
 * createCellSelectContext({ row: 3, col: 1 })
 * // => { coords: { row: 3, col: 1 }, shift: false, ctrl: false }
 *
 * @example
 * // Shift+click to extend
 * createCellSelectContext({ row: 5, col: 2 }, true, false)
 * // => { coords: { row: 5, col: 2 }, shift: true, ctrl: false }
 */
export function createCellSelectContext(coords, shift = false, ctrl = false) {
  if (
    !coords ||
    typeof coords.row !== 'number' ||
    typeof coords.col !== 'number'
  ) {
    throw new Error(
      `Invalid coords: expected { row: number, col: number }, got ${JSON.stringify(
        coords
      )}`
    );
  }

  return Object.freeze({
    coords: Object.freeze({ ...coords }),
    shift,
    ctrl,
  });
}
```

**Rationale:** Matches the existing pattern in `SelectionManager.selectCell(coords, isShift, isCmd)`.

---

## Step 10: Create the Header Select Context Factory

**Action:** Add factory function for header selection context.

```javascript
/**
 * Creates a context object for HEADER_SELECT intents.
 *
 * @param {string} type - 'row' or 'col'
 * @param {number} index - Header index (0-based for cols, 1-based for rows per existing convention)
 * @param {boolean} [shift=false] - Extend selection
 * @param {boolean} [ctrl=false] - Add to selection
 * @returns {Object} Header select context
 */
export function createHeaderSelectContext(
  type,
  index,
  shift = false,
  ctrl = false
) {
  if (type !== 'row' && type !== 'col') {
    throw new Error(`Invalid header type: ${type}. Must be 'row' or 'col'`);
  }
  if (typeof index !== 'number' || index < 0) {
    throw new Error(`Invalid index: ${index}. Must be non-negative number`);
  }

  return Object.freeze({
    type,
    index,
    shift,
    ctrl,
  });
}
```

**Rationale:** Matches existing `SelectionManager.selectHeader(type, index, isShift, isCmd)`.

---

## Step 11: Add Delete Context Factory

**Action:** Add factory for delete context.

```javascript
/**
 * Creates a context object for DELETE intents.
 *
 * @param {string} key - 'backspace' or 'delete'
 * @returns {Object} Delete context
 */
export function createDeleteContext(key) {
  const normalizedKey = key.toLowerCase();
  if (normalizedKey !== 'backspace' && normalizedKey !== 'delete') {
    throw new Error(
      `Invalid delete key: ${key}. Must be 'backspace' or 'delete'`
    );
  }

  return Object.freeze({
    key: normalizedKey,
  });
}
```

**Rationale:** Some modes might want to distinguish between Backspace (delete backward) and Delete (delete forward) for text editing.

---

## Step 12: Add Edit Start Context Factory

**Action:** Add factory for edit start context.

```javascript
/**
 * Creates a context object for EDIT_START intents.
 *
 * @param {string} [source='keyboard'] - What triggered the edit ('keyboard' for F2, 'mouse' for double-click)
 * @returns {Object} Edit start context
 */
export function createEditStartContext(source = 'keyboard') {
  if (source !== 'keyboard' && source !== 'mouse') {
    throw new Error(`Invalid source: ${source}. Must be 'keyboard' or 'mouse'`);
  }

  return Object.freeze({
    source,
  });
}
```

**Rationale:** The edit start source might affect cursor positioning (F2 puts cursor at end, double-click at click position).

---

## Step 13: Create the Unit Test File

**Action:** Create `tests/modes/Intents.test.js`.

```javascript
import { describe, it, expect } from 'vitest';
import {
  INTENTS,
  DIRECTIONS,
  FORMULA_TRIGGERS,
  COMMIT_MOVES,
  createNavigateContext,
  createJumpContext,
  createInputContext,
  createCommitContext,
  createCellSelectContext,
  createHeaderSelectContext,
  createDeleteContext,
  createEditStartContext,
} from '../../js/modes/Intents.js';

describe('Intents', () => {
  describe('INTENTS enum', () => {
    it('should be frozen (immutable)', () => {
      expect(Object.isFrozen(INTENTS)).toBe(true);
    });

    it('should contain all expected navigation intents', () => {
      expect(INTENTS.NAVIGATE).toBe('NAVIGATE');
      expect(INTENTS.JUMP_TO_EDGE).toBe('JUMP_TO_EDGE');
    });

    it('should contain all expected editing intents', () => {
      expect(INTENTS.EDIT_START).toBe('EDIT_START');
      expect(INTENTS.COMMIT).toBe('COMMIT');
      expect(INTENTS.CANCEL).toBe('CANCEL');
      expect(INTENTS.INPUT).toBe('INPUT');
      expect(INTENTS.DELETE).toBe('DELETE');
    });

    it('should contain all expected history intents', () => {
      expect(INTENTS.UNDO).toBe('UNDO');
      expect(INTENTS.REDO).toBe('REDO');
    });

    it('should contain all expected clipboard intents', () => {
      expect(INTENTS.COPY).toBe('COPY');
      expect(INTENTS.PASTE).toBe('PASTE');
      expect(INTENTS.CUT).toBe('CUT');
    });

    it('should contain all expected selection intents', () => {
      expect(INTENTS.SELECT_ALL).toBe('SELECT_ALL');
      expect(INTENTS.CELL_SELECT).toBe('CELL_SELECT');
      expect(INTENTS.HEADER_SELECT).toBe('HEADER_SELECT');
    });

    it('should contain formatting intents', () => {
      expect(INTENTS.FORMAT_BOLD).toBe('FORMAT_BOLD');
      expect(INTENTS.FORMAT_ITALIC).toBe('FORMAT_ITALIC');
    });
  });

  describe('DIRECTIONS enum', () => {
    it('should be frozen', () => {
      expect(Object.isFrozen(DIRECTIONS)).toBe(true);
    });

    it('should contain all four directions', () => {
      expect(DIRECTIONS.UP).toBe('up');
      expect(DIRECTIONS.DOWN).toBe('down');
      expect(DIRECTIONS.LEFT).toBe('left');
      expect(DIRECTIONS.RIGHT).toBe('right');
    });
  });

  describe('createNavigateContext', () => {
    it('should create context with default shift=false', () => {
      const ctx = createNavigateContext(DIRECTIONS.RIGHT);
      expect(ctx).toEqual({ direction: 'right', shift: false });
    });

    it('should create context with shift=true', () => {
      const ctx = createNavigateContext(DIRECTIONS.UP, true);
      expect(ctx).toEqual({ direction: 'up', shift: true });
    });

    it('should return frozen object', () => {
      const ctx = createNavigateContext(DIRECTIONS.DOWN);
      expect(Object.isFrozen(ctx)).toBe(true);
    });

    it('should throw on invalid direction', () => {
      expect(() => createNavigateContext('diagonal')).toThrow(
        'Invalid direction'
      );
    });
  });

  describe('createJumpContext', () => {
    it('should create context with default shift=false', () => {
      const ctx = createJumpContext(DIRECTIONS.RIGHT);
      expect(ctx).toEqual({ direction: 'right', shift: false });
    });

    it('should create context with shift=true for Ctrl+Shift+Arrow', () => {
      const ctx = createJumpContext(DIRECTIONS.RIGHT, true);
      expect(ctx).toEqual({ direction: 'right', shift: true });
    });

    it('should throw on invalid direction', () => {
      expect(() => createJumpContext('nowhere')).toThrow('Invalid direction');
    });
  });

  describe('createInputContext', () => {
    it('should identify regular characters', () => {
      const ctx = createInputContext('a');
      expect(ctx).toEqual({ char: 'a', isFormulaTrigger: false });
    });

    it('should identify = as formula trigger', () => {
      const ctx = createInputContext('=');
      expect(ctx).toEqual({ char: '=', isFormulaTrigger: true });
    });

    it('should identify + as formula trigger', () => {
      const ctx = createInputContext('+');
      expect(ctx).toEqual({ char: '+', isFormulaTrigger: true });
    });

    it('should identify - as formula trigger', () => {
      const ctx = createInputContext('-');
      expect(ctx).toEqual({ char: '-', isFormulaTrigger: true });
    });

    it('should return frozen object', () => {
      const ctx = createInputContext('x');
      expect(Object.isFrozen(ctx)).toBe(true);
    });

    it('should throw on non-string input', () => {
      expect(() => createInputContext(123)).toThrow('Invalid char');
    });

    it('should throw on multi-character string', () => {
      expect(() => createInputContext('ab')).toThrow('Invalid char');
    });

    it('should throw on empty string', () => {
      expect(() => createInputContext('')).toThrow('Invalid char');
    });
  });

  describe('createCommitContext', () => {
    it('should default to move down', () => {
      const ctx = createCommitContext();
      expect(ctx).toEqual({ moveDirection: 'down' });
    });

    it('should accept right direction for Tab', () => {
      const ctx = createCommitContext(COMMIT_MOVES.RIGHT);
      expect(ctx).toEqual({ moveDirection: 'right' });
    });

    it('should accept none direction for click-away', () => {
      const ctx = createCommitContext(COMMIT_MOVES.NONE);
      expect(ctx).toEqual({ moveDirection: 'none' });
    });

    it('should throw on invalid direction', () => {
      expect(() => createCommitContext('up')).toThrow('Invalid moveDirection');
    });
  });

  describe('createCellSelectContext', () => {
    it('should create context with defaults', () => {
      const ctx = createCellSelectContext({ row: 1, col: 0 });
      expect(ctx).toEqual({
        coords: { row: 1, col: 0 },
        shift: false,
        ctrl: false,
      });
    });

    it('should create context with shift', () => {
      const ctx = createCellSelectContext({ row: 5, col: 3 }, true, false);
      expect(ctx.shift).toBe(true);
      expect(ctx.ctrl).toBe(false);
    });

    it('should create context with ctrl', () => {
      const ctx = createCellSelectContext({ row: 2, col: 1 }, false, true);
      expect(ctx.shift).toBe(false);
      expect(ctx.ctrl).toBe(true);
    });

    it('should freeze coords deeply', () => {
      const ctx = createCellSelectContext({ row: 1, col: 1 });
      expect(Object.isFrozen(ctx.coords)).toBe(true);
    });

    it('should throw on invalid coords', () => {
      expect(() => createCellSelectContext(null)).toThrow('Invalid coords');
      expect(() => createCellSelectContext({ row: 'A', col: 1 })).toThrow(
        'Invalid coords'
      );
      expect(() => createCellSelectContext({ row: 1 })).toThrow(
        'Invalid coords'
      );
    });
  });

  describe('createHeaderSelectContext', () => {
    it('should create column header context', () => {
      const ctx = createHeaderSelectContext('col', 2);
      expect(ctx).toEqual({ type: 'col', index: 2, shift: false, ctrl: false });
    });

    it('should create row header context', () => {
      const ctx = createHeaderSelectContext('row', 5, true, false);
      expect(ctx).toEqual({ type: 'row', index: 5, shift: true, ctrl: false });
    });

    it('should throw on invalid type', () => {
      expect(() => createHeaderSelectContext('cell', 1)).toThrow(
        'Invalid header type'
      );
    });

    it('should throw on negative index', () => {
      expect(() => createHeaderSelectContext('col', -1)).toThrow(
        'Invalid index'
      );
    });
  });

  describe('createDeleteContext', () => {
    it('should create backspace context', () => {
      const ctx = createDeleteContext('backspace');
      expect(ctx).toEqual({ key: 'backspace' });
    });

    it('should create delete context', () => {
      const ctx = createDeleteContext('Delete');
      expect(ctx).toEqual({ key: 'delete' });
    });

    it('should normalize to lowercase', () => {
      const ctx = createDeleteContext('BACKSPACE');
      expect(ctx.key).toBe('backspace');
    });

    it('should throw on invalid key', () => {
      expect(() => createDeleteContext('remove')).toThrow('Invalid delete key');
    });
  });

  describe('createEditStartContext', () => {
    it('should default to keyboard source', () => {
      const ctx = createEditStartContext();
      expect(ctx).toEqual({ source: 'keyboard' });
    });

    it('should accept mouse source', () => {
      const ctx = createEditStartContext('mouse');
      expect(ctx).toEqual({ source: 'mouse' });
    });

    it('should throw on invalid source', () => {
      expect(() => createEditStartContext('touch')).toThrow('Invalid source');
    });
  });

  describe('FORMULA_TRIGGERS', () => {
    it('should be frozen', () => {
      expect(Object.isFrozen(FORMULA_TRIGGERS)).toBe(true);
    });

    it('should contain =, +, and -', () => {
      expect(FORMULA_TRIGGERS).toContain('=');
      expect(FORMULA_TRIGGERS).toContain('+');
      expect(FORMULA_TRIGGERS).toContain('-');
    });
  });
});
```

---

## Step 14: Run the Tests

**Action:** Execute the test suite to verify implementation.

```bash
npm test -- tests/modes/Intents.test.js
```

**Expected Result:** All tests pass.

---

## Step 15: Verify No Breaking Changes

**Action:** Run the full test suite to ensure no regressions.

```bash
npm test
npm run e2e
```

**Expected Result:** All existing tests still pass. This file is additive only – nothing depends on it yet.

---

## Final File Structure

After completing this chunk:

```
js/
├── modes/
│   └── Intents.js          ← NEW
├── engine/
├── history/
├── ui/
├── spreadsheet.js
└── ...

tests/
├── modes/
│   └── Intents.test.js     ← NEW
├── engine/
├── history/
└── ui/
```

---

## Complete Source File

For reference, here's the complete `js/modes/Intents.js`:

```javascript
/**
 * Intents.js
 *
 * Defines the semantic vocabulary for user interactions in the spreadsheet.
 *
 * The Intent system decouples "what the user pressed" (raw DOM events) from
 * "what the user wants to do" (semantic actions). This allows:
 *
 * 1. InputController to normalize platform differences (Cmd vs Ctrl)
 * 2. Modes to handle intents without knowing about specific keys
 * 3. Easy remapping of keyboard shortcuts in the future
 *
 * @module modes/Intents
 */

/**
 * Enumeration of all semantic intents in the application.
 * @readonly
 * @enum {string}
 */
export const INTENTS = Object.freeze({
  // Navigation
  NAVIGATE: 'NAVIGATE',
  JUMP_TO_EDGE: 'JUMP_TO_EDGE',

  // Editing Lifecycle
  EDIT_START: 'EDIT_START',
  COMMIT: 'COMMIT',
  CANCEL: 'CANCEL',

  // Text Input
  INPUT: 'INPUT',

  // Deletion
  DELETE: 'DELETE',

  // History
  UNDO: 'UNDO',
  REDO: 'REDO',

  // Clipboard
  COPY: 'COPY',
  PASTE: 'PASTE',
  CUT: 'CUT',

  // Selection
  SELECT_ALL: 'SELECT_ALL',
  CELL_SELECT: 'CELL_SELECT',
  HEADER_SELECT: 'HEADER_SELECT',

  // Formatting
  FORMAT_BOLD: 'FORMAT_BOLD',
  FORMAT_ITALIC: 'FORMAT_ITALIC',
});

/**
 * Valid directions for navigation intents.
 * @readonly
 * @enum {string}
 */
export const DIRECTIONS = Object.freeze({
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right',
});

/**
 * Characters that trigger formula mode when typed in Ready state.
 * @readonly
 */
export const FORMULA_TRIGGERS = Object.freeze(['=', '+', '-']);

/**
 * Valid move directions after commit.
 * @readonly
 * @enum {string}
 */
export const COMMIT_MOVES = Object.freeze({
  DOWN: 'down',
  RIGHT: 'right',
  NONE: 'none',
});

// ============================================================================
// Context Factory Functions
// ============================================================================

/**
 * Creates a context object for NAVIGATE intents.
 */
export function createNavigateContext(direction, shift = false) {
  if (!Object.values(DIRECTIONS).includes(direction)) {
    throw new Error(
      `Invalid direction: ${direction}. Must be one of: ${Object.values(
        DIRECTIONS
      ).join(', ')}`
    );
  }
  return Object.freeze({ direction, shift });
}

/**
 * Creates a context object for JUMP_TO_EDGE intents.
 */
export function createJumpContext(direction, shift = false) {
  if (!Object.values(DIRECTIONS).includes(direction)) {
    throw new Error(
      `Invalid direction: ${direction}. Must be one of: ${Object.values(
        DIRECTIONS
      ).join(', ')}`
    );
  }
  return Object.freeze({ direction, shift });
}

/**
 * Creates a context object for INPUT intents.
 */
export function createInputContext(char) {
  if (typeof char !== 'string' || char.length !== 1) {
    throw new Error(
      `Invalid char: expected single character string, got ${typeof char}: ${char}`
    );
  }
  return Object.freeze({
    char,
    isFormulaTrigger: FORMULA_TRIGGERS.includes(char),
  });
}

/**
 * Creates a context object for COMMIT intents.
 */
export function createCommitContext(moveDirection = COMMIT_MOVES.DOWN) {
  if (!Object.values(COMMIT_MOVES).includes(moveDirection)) {
    throw new Error(
      `Invalid moveDirection: ${moveDirection}. Must be one of: ${Object.values(
        COMMIT_MOVES
      ).join(', ')}`
    );
  }
  return Object.freeze({ moveDirection });
}

/**
 * Creates a context object for CELL_SELECT intents.
 */
export function createCellSelectContext(coords, shift = false, ctrl = false) {
  if (
    !coords ||
    typeof coords.row !== 'number' ||
    typeof coords.col !== 'number'
  ) {
    throw new Error(
      `Invalid coords: expected { row: number, col: number }, got ${JSON.stringify(
        coords
      )}`
    );
  }
  return Object.freeze({
    coords: Object.freeze({ ...coords }),
    shift,
    ctrl,
  });
}

/**
 * Creates a context object for HEADER_SELECT intents.
 */
export function createHeaderSelectContext(
  type,
  index,
  shift = false,
  ctrl = false
) {
  if (type !== 'row' && type !== 'col') {
    throw new Error(`Invalid header type: ${type}. Must be 'row' or 'col'`);
  }
  if (typeof index !== 'number' || index < 0) {
    throw new Error(`Invalid index: ${index}. Must be non-negative number`);
  }
  return Object.freeze({ type, index, shift, ctrl });
}

/**
 * Creates a context object for DELETE intents.
 */
export function createDeleteContext(key) {
  const normalizedKey = key.toLowerCase();
  if (normalizedKey !== 'backspace' && normalizedKey !== 'delete') {
    throw new Error(
      `Invalid delete key: ${key}. Must be 'backspace' or 'delete'`
    );
  }
  return Object.freeze({ key: normalizedKey });
}

/**
 * Creates a context object for EDIT_START intents.
 */
export function createEditStartContext(source = 'keyboard') {
  if (source !== 'keyboard' && source !== 'mouse') {
    throw new Error(`Invalid source: ${source}. Must be 'keyboard' or 'mouse'`);
  }
  return Object.freeze({ source });
}
```

---

## Checklist Before Moving to Chunk 1.2

- [ ] `js/modes/Intents.js` created with all exports
- [ ] `tests/modes/Intents.test.js` created with comprehensive tests
- [ ] All new tests pass (`npm test -- tests/modes/Intents.test.js`)
- [ ] All existing tests still pass (`npm test`)
- [ ] E2E tests still pass (`npm run e2e`)
- [ ] Code follows existing project conventions (ES6 modules, JSDoc)

---

## Next Step

Proceed to **Chunk 1.2: AbstractMode Base Class** – defining the interface contract for all mode strategies.
